plugins {
	id 'java-library'
	id 'eclipse'
}

repositories {
	mavenCentral()
	maven {
		url "https://repo.spongepowered.org/maven/"
	}
	maven {
		url "https://maven.fabricmc.net/"
	}
}

sourceCompatibility = '9'
targetCompatibility = '9'

version = wilderForgeVersion
group = "com.wildermods"
archivesBaseName = "wilderforge"

configurations {
	excludeFat
	implementation.extendsFrom(excludeFat)
}

dependencies {

	implementation group: 'org.apache.commons', name: 'commons-text', version: '1.9'
	implementation group: 'org.jetbrains', name: 'intellij-fernflower', version: '1.2.1.16'
	implementation group: 'org.jgrapht', name: 'jgrapht-core', version: '1.5.1'
	implementation group: 'net.fabricmc', name: 'access-widener', version: '2.1.0'
	implementation group: 'net.fabricmc', name: 'fabric-loader', version: '0.12.11'
	implementation group: 'net.fabricmc', name: 'tiny-mappings-parser', version:'0.3.0+'
	implementation group: 'net.oneandone.reflections8', name: 'reflections8', version: '0.11.5'
	implementation group: 'net.sf.jopt-simple', name: 'jopt-simple', version: '6.0-alpha-3'

	//mixin requirements:
	implementation 'org.spongepowered:mixin:' + mixinVersion
	implementation 'com.google.guava:guava:21.0'
	implementation group: 'com.google.code.gson', name: 'gson', version: '2.8.7'
	implementation group: 'org.ow2.asm', name: 'asm', version: asmVersion
	implementation group: 'org.ow2.asm', name: 'asm-analysis', version: asmVersion
	implementation group: 'org.ow2.asm', name: 'asm-commons', version: asmVersion
	implementation group: 'org.ow2.asm', name: 'asm-tree', version: asmVersion
	implementation group: 'org.ow2.asm', name: 'asm-util', version: asmVersion
	
	/*
	*
	* CVE-2021-44228 DO NOT REMOVE
	*
	*/
	implementation group: 'org.apache.logging.log4j', name: 'log4j-api', version: '2.16.0'
	implementation group: 'org.apache.logging.log4j', name: 'log4j-core', version: '2.16.0'
	implementation group: 'org.apache.logging.log4j', name: 'log4j-slf4j18-impl', version: '2.16.0'


	/**********
	don't alter the dependencies below
	***********/
	
	//Wildermyth, Scratchpad
	excludeFat fileTree(dir: './bin/', include: ['*.jar'])
	
	//All dependencies of Wildermyth itself
	excludeFat fileTree(dir: './bin/lib/', include: ['*.jar'])
}

processResources {
	filesMatching('mod.json') {
		expand "WILDERFORGE_VERSION": project.version
	}
}

eclipse {
	classpath {
		file {
			whenMerged {
				def decomp = fileReference(file('bin/decomp'))
				def lib = entries.find { it.path.contains 'wildermyth.jar'}
				lib.sourcePath = decomp
				lib = entries.find { it.path.contains 'scratchpad.jar'}
				lib.sourcePath = decomp
				lib = entries.find { it.path.contains 'server-1.0.jar'}
				lib.sourcePath = decomp
				lib = entries.find { it.path.contains 'gameEngine-1.0.jar'}
				lib.sourcePath = decomp
				lib = entries.find { it.path.contains 'fmod-jni.jar'}
				lib.sourcePath = decomp
			}
		}
	}
}

import org.slf4j.LoggerFactory
import java.nio.file.DirectoryStream
import java.nio.file.Path
import java.nio.file.Files
import java.nio.file.FileSystems
import java.nio.file.FileSystem

jar {
	archiveBaseName = archiveBaseName.get() + "-fat"
	manifest {
		attributes(
			'Class-Path': configurations.runtimeClasspath.collect { it.getName() }.join(' '),
			'MixinConfigs': 'wilderforge.mixins.json',
			'Main-Class': 'net.fabricmc.loader.impl.launch.knot.KnotClient',
			'Specification-Version': 8.0,
			'Multi-Release': 'true'
		)
	}
	
	def serviceDir = file("$buildDir/META-INF/services")
	serviceDir.deleteDir();
	serviceDir.mkdirs()
	
	logger.error("locating services")
	for(file in configurations.runtimeClasspath - configurations.excludeFat) {
		zipTree(file).matching {include '**META-INF/services/*'}.each { f -> 
			File serviceFile = new File(serviceDir, f.name)
			if(serviceFile.exists()) {
				logger.error("Note: duplicate service file " + serviceFile)
			}
			new File(serviceDir, f.name) << (f.getText("UTF-8") + "\n")
		}
	}

	duplicatesStrategy = 'INCLUDE'
	def serviceZip = file("$buildDir/META-INF/services/services.zip")
	
	HashMap<String, BufferedWriter> SERVICE_WRITERS = new HashSet<>();
	
	eachFile {
		f -> 
			//logger.error(f as String)
			if((f as String).contains("META-INF/services/")) {
				String name = f.getPath().toString()
				name = name.substring(name.lastIndexOf('/'))
				File serviceFile = new File(serviceDir, name)
				//logger.error("Found service file at " + f as String)
				//logger.error("Class: " + f.getClass())
				if(SERVICE_WRITERS.containsKey(name)) {
					logger.error("Mushing: duplicate service file " + name)
					SERVICE_WRITERS.get(name).newLine();
				}
				else {
					logger.error("Found new service file " + name)
					serviceFile.createNewFile()
					SERVICE_WRITERS.put(name, new BufferedWriter(new FileWriter(serviceFile)))
				}
				SERVICE_WRITERS.get(name).write(f.open().text)
			}
	}
	from {
		[
			(configurations.runtimeClasspath - configurations.excludeFat).collect {
				logger.error(it as String)
				exclude 'LICENSE.txt'
				it.isDirectory() ? it : zipTree(it)
			}
		]
	}
	doLast{
		for(BufferedWriter writer : SERVICE_WRITERS.values()) {
			try {
				writer.close()
				logger.error("closed writer")
			}
			catch(IOException e) {
				logger.error(e)
			}
		}
		
		URI uri = URI.create("jar:file:" + archiveFile.getAsFile().get().getAbsolutePath())
		
		FileSystem jarFS;
		FileHelper fileHelper = new FileHelper(logger);
		
		try {
			jarFS = FileSystems.newFileSystem(uri, Collections.singletonMap("create", "false"))
		}
		catch(Exception e) {
			logger.error("", e)
			jarFS = FileSystems.getFileSystem(uri);
			jarFS.close();
			try {
				jarFS = FileSystems.getFileSystem(uri);
				throw new AssertionError();
			}
			catch(Throwable t){
				logger.error("zip filesystem in invalid state... restart your system?")
				throw t;
			}
			jarFS = FileSystems.newFileSystem(uri, Collections.singletonMap("create", "false"))
		}
		try {
			Path servicesPath = jarFS.getPath("META-INF/services/")
			
			//logger.error(servicesPath as String)
			
			fileHelper.deleteWithChildren(servicesPath);
			Files.createDirectory(servicesPath)
			
			Path newServicesPath = Path.of(serviceDir.getPath())
			
			fileHelper.copyWithChildren(newServicesPath, servicesPath)
		}
		finally {
			jarFS.close();
		}
		
	}
	doLast{logger.error("???")}
}


class FileHelper {

	def logger;
	
	public FileHelper(Object logger) {
		this.logger = logger;
	}

	void deleteWithChildren(Path path) {
		for(Path subPath : Files.newDirectoryStream(path)) {
			if(!Files.isDirectory(subPath)) {
				logger.error("deleting " + subPath)
				Files.delete(subPath);
			}
			else {
				deleteWithChildren(Files.newDirectoryStream(subPath));
			}
		}
		logger.error("deleting directory " + path);
		Files.delete(path)
	}
	
	void copyWithChildren(Path srcPath, Path destPath) {
		DirectoryStream directoryStream = Files.newDirectoryStream(srcPath);
		for(Path srcPath2 : directoryStream) {
			logger.error(srcPath2 as String);
		}
	}
}

/*task fatJar(type: Jar) {
	destinationDirectory = jar.destinationDirectory;
	archiveBaseName = jar.archiveBaseName.get() + "-fat"
	logger.error("fattening");
	logger.error(jar.archiveFile.get() as String);
	from(jar.collect()) {
		eachFile {
			it.isDirectory() ? it : zipTree(it)
		}
	}
	doLast {
		logger.error("WHY IS THIS NOT RUNNING!")
	}
}*/